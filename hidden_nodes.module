<?php
/**
 * @file
 * Allow users to hide nodes based on permissions.
 */

/**
 * Implementation of hook_init().
 *
 * Loads nessecary css onto the page to overlay hidden elements
 */
function hidden_nodes_init() {
  drupal_add_css(drupal_get_path('module', 'hidden_nodes') .'/hidden_nodes.css');
}

/**
 * Implementation of hook_perm().
 *
 * Adds a global 'view hidden content' to see anything hidden.
 */
function hidden_nodes_perm() {
  return array('view hidden content');
}

/**
 * Implementation of hook_menu().
 */
function hidden_nodes_menu() {
  $items = array();
  $items['admin/settings/hidden_nodes'] = array(
    'title' => 'Hidden nodes',
    'description' => 'Settings for Hidden nodes module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hidden_nodes_setting_page'),
    'file' => 'hidden_nodes.admin.inc',
    'access arguments' => array('administer site configuration'),
  );
  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function hidden_nodes_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'insert':
    case 'update':
      // if node's ability to be hidden is valid, save it
      if (isset($node->hidden)) {
        db_query("UPDATE {hidden_nodes} SET hidden=%d WHERE nid=%d", $node->hidden, $node->nid);
        // if there was no update then insert new
        if (!db_affected_rows()) {
          @db_query("INSERT INTO {hidden_nodes} (nid, hidden) VALUES(%d, %d)", $node->nid, $node->hidden);
        }
      }
    break;
    case 'load':
      // set hidden value if this is a valid type
      if (in_array($node->type, variable_get('hidden_nodes_types', array()))) {
        $node->hidden = _hidden_nodes_get_status($node->nid);
        if (empty($node->hidden)) {
          $node->hidden = 0;
        }
      }
    break;
    case 'view':
      // if this is hidden and global message set
      if (isset($node->hidden) && variable_get('hidden_nodes_show_message', 1)) {
        // display message if hidden is true
        if ($node->hidden) {
          drupal_set_message(t('This content is currently hidden and not displayed to certain user roles.'), 'warning', FALSE);
        }
        // book module integration, check parents for hidden status to report more accurately
        elseif (isset($node->book)) {
          $parents = array();
          // ignore p1 as its always the page itself and there are only 8 parents allowed
          for ($i = 2; $i<10; $i++) {
            // if parent has an mlid then it exists in the book router table potentially
            if ($node->book['p'. $i] != 0) {
              $parents[] = $node->book['p'. $i];
            }
          }
          // if there are parents, perform the join otherwise we are done
          if (count($parents) > 0) {
            // if we count parents that are hidden, report that fact
            if (db_result(db_query("SELECT COUNT(hn.nid) FROM {hidden_nodes} AS hn JOIN {book} AS b ON hn.nid=b.nid WHERE mlid IN (" . db_placeholders($parents) . ") AND hidden=1", $parents))) {
              drupal_set_message(t('This content is not hidden, but it has some parent content that is and will not display in most menus as a result.'), 'warning', FALSE);
            }
          }
        }
      }
    break;
    case 'delete':
      // clean up on node delete
      db_query("DELETE FROM {hidden_nodes} WHERE nid=%d", $node->nid);
    break;
  }
}

/**
 * Implements hook_form_alter().
 */
function hidden_nodes_form_alter(&$form, $form_state, $form_id) {
  // inject new option to hide node onto all node forms
  if (isset($form['type']['#value']) && $form['type']['#value'] . '_node_form' == $form_id) {
    // Get a copy of the current node object.
    $node = $form['#node'];
    // add field to the form if the setting is there for it
    if (in_array($node->type, variable_get('hidden_nodes_types', array()))) {
      $form['hidden_nodes'] = array(
        '#type' => 'fieldset',
        '#title' => t('Hide content'),
        '#description' => t('Hide this content from displaying for users without the ability to see it. By having access to this option you will still be able to see the content after submission.'),
        '#collapsible' => TRUE,
        '#collapsed' => !($node->hidden),
        '#access' => user_access('view hidden content'),
      );
      $form['hidden_nodes']['hidden'] = array(
        '#type' => 'checkbox',
        '#title' => t('Hide this content'),
        '#default_value' => $node->hidden,
        '#access' => user_access('view hidden content'),
      );
    }
  }
  // book form integration
  if ($form_id == 'book_admin_edit') {
    // select just the table
    $hidden_parents = array();
    foreach ($form['table'] as $key => $row) {
      // make sure we have a row in the table
      if (is_array($row)) {
        // if the attributes for the menu item have been set, add the classes
        if (isset($row['#item']['options']['attributes'])) {
          // if class is found, apply styling
          if (strpos($row['#item']['options']['attributes']['class'], 'node_is_hidden') !== FALSE) {
            $form['table'][$key]['#attributes'] = array('class' => 'node_is_hidden');
            // list this as a hidden parent if node_is_hidden is found
            $hidden_parents[$key] = $row['mlid']['#default_value'];
          }
        }
        // if we find something that has a parent that is hidden, propagate class
        if (in_array($row['plid']['#default_value'], $hidden_parents)) {
          $form['table'][$key]['#attributes'] = array('class' => 'node_is_hidden');
          // add this to the hidden list so it can propagate further
          $hidden_parents[$key] = $row['mlid']['#default_value'];
        }
      }
    }
  }
}

/**
 * Implementation of hook_node_grants().
 */
function hidden_nodes_node_grants($account, $op) {
  $grants = array();
  // if operation is to view and they have view hidden nodes perm
  if ($op == 'view' && user_access('view hidden content', $account)) {
    $grants['hidden_nodes'] = array(1);
  }
  return $grants;
}

/**
 * Implementation of hook_node_access_records().
 */
function hidden_nodes_node_access_records($node) {
  $grants = array();
  // only return grants if hidden is true
  if ($node->hidden) {
    $grants[] = array(
      'realm' => 'hidden_nodes',
      'gid' => 1,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 1000, // very high in hopes it is always first
    );
  }
  return $grants;
}

/**
 * Implementation of hook_node_access_explain().
 */
function hidden_nodes_node_access_explain($row) {
  if ($row->realm == 'hidden_nodes') {
    return t('Users with permission to see hidden nodes will.');
  }
}

/**
 * Implementation of hook_menu_link_alter().
 */
function hidden_nodes_menu_link_alter(&$item, $menu) {
  // if we have a node based menu object
  if (isset($item['nid'])) {
    // need to directly access database as static cache of object is invalid
    // this happens because page save would change the value of hidden
    if (_hidden_nodes_get_status($item['nid'])) {
      $item['options']['attributes']['class'] = ' node_is_hidden';
    }
    else{
      // we do this to avoid potential conflicts with menu attributes modules
      $item['options']['attributes']['class'] = str_replace(' node_is_hidden', '', $item['options']['attributes']['class']);
    }
  }
}

/**
 * Helper function to return hidden status based on nid.
 */
function _hidden_nodes_get_status($nid) {
  return db_result(db_query('SELECT hidden FROM {hidden_nodes} WHERE nid = %d', $nid));
}

/**
 * Implementation of hook_outline_designer_operations().
 */
function hidden_nodes_outline_designer_operations($type) {
  switch ($type) {
    case 'book':
      $ops = array(
        'hidden_nodes' => array(
          'title' => t('Hide node'),
          'icon' => drupal_get_path('module', 'hidden_nodes') .'/images/hidden_node.png',
          'callback' => 'hidden_nodes_outline_designer_hide_node',
        ),
      );
    break;
    default:
      $ops = array();
    break;
  }
  return $ops;
}

/**
 * Implementation of hook_outline_designer_ops_js().
 */
function hidden_nodes_outline_designer_ops_js($ajax_path) {
  drupal_add_js(drupal_get_path('module', 'hidden_nodes') .'/js/hidden_nodes_ops.js', 'footer');
  return 1;
}

/**
 * Implementation of hook_outline_designer_form_overlay().
 */
function hidden_nodes_outline_designer_form_overlay() {
  // delete form
  $form['od_hidden_nodes_multiple'] = array(
   '#title' => t('Propagate hidden status'),
   '#id' => 'od_hidden_nodes_multiple',
   '#type' => 'checkbox',
   '#description' => t('Should this status be applied to all child content?'),
   '#weight' => 0,
   '#default_value' => TRUE,
  );
  // hidden status
  $form['od_hidden_nodes_status'] = array(
   '#title' => t('Hide content'),
   '#id' => 'od_hidden_nodes_status',
   '#type' => 'checkbox',
   '#description' => t('Hide this content'),
   '#weight' => 0,
   '#default_value' => FALSE,
  );
  $output = '<div id="od_hidden_nodes" class="od_uiscreen">'. drupal_render($form) .'</div>';
  return $output;
}
/**
 * Helper function to process the ajax callback for hiding a node
 */
function hidden_nodes_outline_designer_hide_node($nid, $multiple, $status) {
  // load node
  $node = node_load($nid);
  // verify this type can be hidden and node access rights
  if (isset($node->nid) && in_array($node->type, variable_get('hidden_nodes_types', array())) && node_access('update', $node) && user_access('view hidden content') && in_array($status, array(0, 1)) && $status != $node->hidden) {
    // verify the status has changed and is a valid value
    $node->hidden = $status;
    node_save($node);
    // if the multiple flag is set then iterate down
    if ($multiple) {
      // pull only the nodes that have the original node as a parent
      $mlid = $node->book['mlid'];
      // ensure this is a real value
      if ($mlid != 0 && $mlid != '') {
        $result = db_query("
        SELECT link_path
        FROM {menu_links}
        WHERE p2=%d OR p3=%d OR p4=%d OR p5=%d OR p6=%d OR p7=%d OR p8=%d OR p9=%d
        ORDER BY depth ASC", $mlid, $mlid, $mlid, $mlid, $mlid, $mlid, $mlid, $mlid);
        while ($value = db_fetch_array($result)) {
          $current_node = node_load(str_replace('node/', '', $value['link_path']));
          if (isset($current_node->nid) && in_array($current_node->type, variable_get('hidden_nodes_types', array())) && node_access('update', $current_node) && $status != $current_node->hidden) {
            $current_node->hidden = $status;
            node_save($current_node);
          }
        }
      }
    }
    return t('Content was marked hidden successfully');
  }
}